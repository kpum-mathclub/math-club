<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>京都府立医科大学数学研究部 | Math Club</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background: white;
      overflow-x: hidden;
    }

    nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: #111;
      color: white;
      padding: 12px 24px;
      z-index: 999;
      font-size: 18px;
      display: flex;
      gap: 20px;
      font-family: "Noto Serif JP", serif;
    }

    nav a { color: white; text-decoration: none; }

    body { padding-top: 70px; }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      pointer-events: none; /* 背景だけなのでイベント透過 */
      z-index: -10;
    }

    /* 右下の6方向D-Pad */
    .dpad {
      position: fixed;
      right: 20px;
      bottom: 20px;
      width: 168px;
      height: 168px;
      z-index: 1000;
      user-select: none;
    }
    .dbtn {
      position: absolute;
      width: 48px; height: 48px;
      border-radius: 50%;
      border: 1px solid #333;
      background: #fff;
      box-shadow: 0 2px 6px rgba(0,0,0,.25);
      font-size: 20px;
      line-height: 48px;
      text-align: center;
      cursor: pointer;
    }
    .dbtn:active { transform: translateY(1px); }
    .dbtn.r  { left: 120px; top:  60px; }  /* → */
    .dbtn.ur { left: 120px; top:  20px; }  /* ↗ */
    .dbtn.dr { left: 120px; top: 100px; }  /* ↘ */
    .dbtn.l  { left:  20px; top:  60px; }  /* ← */
    .dbtn.ul { left:  20px; top:  20px; }  /* ↖ */
    .dbtn.dl { left:  20px; top: 100px; }  /* ↙ */
  </style>
</head>

<body>

<nav>
  <a href="index.html">Home</a>
  <a href="schedule.html">Schedule</a>
  <a href="contact.html">Contact</a>
  <a href="qa.html">Q&A</a>
</nav>

<div class="corner-message" style="position:fixed;top:72px;left:20px;font-size:20px;color:#111;font-weight:bold;z-index:10;pointer-events:none;font-family:'Noto Serif JP',serif;">
  京都府立医科大学 数学研究部 公式HP
</div>

<!-- 右下コントローラー -->
<div class="dpad" id="dpad">
  <button class="dbtn ul" data-dir="ul">↖</button>
  <button class="dbtn ur" data-dir="ur">↗</button>
  <button class="dbtn l"  data-dir="l">←</button>
  <button class="dbtn r"  data-dir="r">→</button>
  <button class="dbtn dl" data-dir="dl">↙</button>
  <button class="dbtn dr" data-dir="dr">↘</button>
</div>

<script>
new p5(p => {
  const sideLength = 60;
  const walkerCount = 300;
  let triangles = [];
  let points = [];
  let adjacency = new Map();
  let walkers = [];
  let boosting = false; // 既存変数は温存（未使用）

  // ===== Safety area（長方形） =====
  let safetyRect = {x:0,y:0,w:0,h:0};
  function computeSafetyRect(){
    // 画面左上に固定（D-Padと被らないよう適度なサイズ）
    const w = Math.min(420, Math.max(240, p.width * 0.38));
    const h = Math.min(360, Math.max(200, p.height * 0.28));
    safetyRect = { x: 24, y: 110, w, h };
  }
  function isInsideSafetyArea(v){
    return v.x >= safetyRect.x && v.x <= safetyRect.x + safetyRect.w &&
           v.y >= safetyRect.y && v.y <= safetyRect.y + safetyRect.h;
  }

  // ===== START / GOAL 固定（Safety内の2点） =====
  let startPoint = null, goalPoint = null;
  function pickStartAndGoalFixed(){
    // 左上隅寄り & 右下隅寄りに固定し、最寄り頂点へスナップ
    const s = getNearestVertex(safetyRect.x + 16, safetyRect.y + 16);
    const g = getNearestVertex(safetyRect.x + safetyRect.w - 16, safetyRect.y + safetyRect.h - 16);
    startPoint = s; goalPoint = g;
  }

  // ===== Manual（緑）Walker（辺上のみ） =====
  const SQ3 = Math.sqrt(3);
  const DIR = {
    r:  {x:  1.0, y:  0.0},
    ur: {x:  0.5, y: -SQ3/2},
    dr: {x:  0.5, y:  SQ3/2},
    l:  {x: -1.0, y:  0.0},
    ul: {x: -0.5, y: -SQ3/2},
    dl: {x: -0.5, y:  SQ3/2},
  };
  let manualWalker;
  let gameOver = false;

  class ManualWalker {
    constructor(startVec) {
      this.current = startVec;
      this.next = null;
      this.t = 0;
    }
    isMoving(){ return !!this.next; }
    stepByDirection(dirKey){
      if (this.isMoving() || gameOver) return;
      const d = DIR[dirKey];
      const key = this.current.x + "," + this.current.y;
      const nbrs = adjacency.get(key)?.neighbors || [];
      let best = null, bestDot = 0.1;
      for (const n of nbrs){
        const vx = n.x - this.current.x, vy = n.y - this.current.y;
        const dot = vx*d.x + vy*d.y;
        if (dot > bestDot){ bestDot = dot; best = n; }
      }
      if (best){ this.next = best; this.t = 0; }
    }
    update(){
      if (this.next){
        this.t += 0.08;
        if (this.t >= 1){
          this.current = this.next;
          this.next = null;
          this.t = 0;
        }
      }
    }
    getPosition(){
      if (this.next){
        return p.createVector(
          p.lerp(this.current.x, this.next.x, this.t),
          p.lerp(this.current.y, this.next.y, this.t)
        );
      }
      return this.current.copy();
    }
    display(){
      const pos = this.getPosition();
      p.noStroke();
      p.fill(0, 255, 0, 60);
      p.ellipse(pos.x, pos.y, 24);
      p.fill(0, 180, 0);
      p.ellipse(pos.x, pos.y, 8);
    }
  }

  // ===== 既存の自動walker（黒）。Safety内に入らないよう制限 =====
  class Walker {
    constructor() {
      this.current = randomPointOutsideSafety();
      this.next = this.chooseNext(this.current);
      this.t = 0;
      this.baseSpeed = p.random(0.003, 0.008);
      this.phase = p.random(p.TWO_PI);
    }
    chooseNext(current) {
      const key = current.x + ',' + current.y;
      const options = adjacency.get(key)?.neighbors || [];
      // Safetyに入る候補は除外
      const filtered = options.filter(v => !isInsideSafetyArea(v));
      const pool = filtered.length ? filtered : options.filter(v => v !== current);
      if (!pool.length) return current;
      let next;
      do {
        next = p.random(pool);
      } while (next.x === current.x && next.y === current.y && pool.length > 1);
      return next;
    }
    update() {
      const speedMultiplier = 1;
      this.t += this.baseSpeed * speedMultiplier;
      if (this.t >= 1) {
        this.current = this.next;
        this.next = this.chooseNext(this.current);
        this.t = 0;
      }
    }
    getPosition(){
      return {
        x: p.lerp(this.current.x, this.next.x, this.t),
        y: p.lerp(this.current.y, this.next.y, this.t)
      };
    }
    display() {
      const pos = this.getPosition();
      const size = 6 + p.sin(p.frameCount * 0.05 + this.phase) * 2;
      const glow = 20 + 10 * p.sin(p.frameCount * 0.08 + this.phase);
      p.noStroke();
      p.fill(0, 0, 0, 25);
      p.ellipse(pos.x, pos.y, size + glow);
      p.fill(0);
      p.ellipse(pos.x, pos.y, size);
    }
  }

  function randomPointOutsideSafety(){
    const outside = points.filter(pt => !isInsideSafetyArea(pt));
    return outside.length ? p.random(outside) : p.random(points);
  }

  // ===== p5: setup =====
  p.setup = () => {
    const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    const cnv = p.createCanvas(p.windowWidth, height);
    cnv.position(0, 0);

    generateTriangleGrid();
    computeSafetyRect();
    pickStartAndGoalFixed();

    // 自動walkersを配置（Safety外から開始）
    walkers = [];
    for (let i = 0; i < walkerCount; i++) {
      walkers.push(new Walker());
    }

    // 緑点をSTARTへ
    manualWalker = new ManualWalker(startPoint);

    // D-Padバインド
    setupDpad();
  };

  // ===== p5: draw =====
  p.draw = () => {
    p.background(255);

    // タイル
    p.noFill();
    p.stroke(0, 40);
    for (let t of triangles) {
      p.beginShape();
      for (let pt of t) p.vertex(pt.x, pt.y);
      p.endShape(p.CLOSE);
    }

    // Safety area（下地）
    drawSafetyArea();

    // START / GOAL
    drawStartGoal();

    // 自動walkers
    for (let w of walkers) { w.update(); w.display(); }

    // 緑walker
    manualWalker.update();
    manualWalker.display();

    // 衝突判定 → Game Over
    if (!gameOver && checkCollision()){
      gameOver = true;
      drawGameOver();
      p.noLoop();
      return;
    }
  };

  // ===== Safety area描画 =====
  function drawSafetyArea(){
    p.push();
      p.noStroke();
      p.fill(255, 230, 140, 90); // 薄い黄色の安全地帯
      p.rect(safetyRect.x, safetyRect.y, safetyRect.w, safetyRect.h, 8);
      p.stroke(200, 160, 60);
      p.noFill();
      p.rect(safetyRect.x, safetyRect.y, safetyRect.w, safetyRect.h, 8);
      p.fill(120, 90, 30);
      p.noStroke();
      p.textSize(12);
      p.text("SAFETY AREA", safetyRect.x + 8, safetyRect.y + 16);
    p.pop();
  }

  // ===== START / GOAL描画 =====
  function drawStartGoal(){
    if (!startPoint || !goalPoint) return;
    // START
    p.push();
      p.noFill();
      p.stroke(0,180,0,220);
      p.strokeWeight(2);
      p.ellipse(startPoint.x, startPoint.y, 18);
      p.noStroke();
      p.fill(0,180,0,140);
      p.ellipse(startPoint.x, startPoint.y, 6);
      p.fill(0,150,0);
      p.textSize(12);
      p.text("START", startPoint.x + 12, startPoint.y - 10);
    p.pop();
    // GOAL
    const pulse = 22 + 6 * Math.sin(p.frameCount * 0.07);
    p.push();
      p.noFill();
      p.stroke(0,120,255,220);
      p.strokeWeight(2);
      p.ellipse(goalPoint.x, goalPoint.y, pulse);
      p.noStroke();
      p.fill(0,120,255);
      p.ellipse(goalPoint.x, goalPoint.y, 6);
      p.fill(0,120,255);
      p.textSize(12);
      p.text("GOAL", goalPoint.x + 12, goalPoint.y - 10);
    p.pop();
  }

  // ===== 衝突判定 =====
  function checkCollision(){
    const mp = manualWalker.getPosition();
    const threshold = 12;
    for (const w of walkers){
      const pos = w.getPosition();
      if (p.dist(mp.x, mp.y, pos.x, pos.y) < threshold){
        return true;
      }
    }
    return false;
  }

  function drawGameOver(){
    p.fill(255, 0, 0);
    p.noStroke();
    p.textAlign(p.CENTER, p.CENTER);
    p.textSize(64);
    p.text("GAME OVER", p.width/2, p.height/2);
  }

  // ===== 格子生成（既存） =====
  function generateTriangleGrid() {
    const h = sideLength * Math.sqrt(3) / 2;
    triangles = [];
    adjacency.clear();

    for (let y = 0; y < p.height + h; y += h) {
      for (let x = 0; x < p.width + sideLength; x += sideLength) {
        const xOffset = (Math.floor(y / h) % 2) * (sideLength / 2);
        const p1 = p.createVector(x + xOffset, y);
        const p2 = p.createVector(x + sideLength / 2 + xOffset, y + h);
        const p3 = p.createVector(x - sideLength / 2 + xOffset, y + h);
        triangles.push([p1, p2, p3]);

        registerEdge(p1, p2);
        registerEdge(p2, p3);
        registerEdge(p3, p1);
      }
    }
    points = Array.from(adjacency.values()).map(obj => obj.vec);
  }

  function registerEdge(a, b) {
    const keyA = a.x + ',' + a.y;
    const keyB = b.x + ',' + b.y;

    if (!adjacency.has(keyA)) adjacency.set(keyA, { vec: a, neighbors: [] });
    if (!adjacency.has(keyB)) adjacency.set(keyB, { vec: b, neighbors: [] });

    const neighborsA = adjacency.get(keyA).neighbors;
    const neighborsB = adjacency.get(keyB).neighbors;

    if (!neighborsA.some(n => n.x === b.x && n.y === b.y)) neighborsA.push(adjacency.get(keyB).vec);
    if (!neighborsB.some(n => n.x === a.x && n.y === a.y)) neighborsB.push(adjacency.get(keyA).vec);
  }

  function getNearestVertex(x, y) {
    let nearest = null, minDist = Infinity;
    for (let pt of points) {
      const d = p.dist(x, y, pt.x, pt.y);
      if (d < minDist) { minDist = d; nearest = pt; }
    }
    return nearest;
  }

  // ===== D-Pad イベント =====
  function setupDpad(){
    const dpad = document.getElementById('dpad');
    const bind = dir => e => { e.preventDefault(); manualWalker.stepByDirection(dir); };
    ['ul','ur','l','r','dl','dr'].forEach(dir=>{
      const btn = dpad.querySelector(`.dbtn.${dir}`);
      if (!btn) return;
      btn.addEventListener('click',      bind(dir), {passive:false});
      btn.addEventListener('touchstart', bind(dir), {passive:false});
    });
  }

  // ===== リサイズ =====
  p.windowResized = () => {
    p.resizeCanvas(
      p.windowWidth,
      Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
    );
    generateTriangleGrid();
    computeSafetyRect();
    pickStartAndGoalFixed();
    // 緑点をSTARTへ戻す（固定仕様）
    if (manualWalker) { manualWalker.current = startPoint; manualWalker.next = null; manualWalker.t = 0; }
    // 既存walkersはそのまま。新規生成はせず（元の構造に合わせる）
  };
});
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>京都府立医科大学数学研究部 | Math Club</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background: white;
      overflow-x: hidden;
    }

    nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: #111;
      color: white;
      padding: 12px 24px;
      z-index: 999;
      font-size: 18px;
      display: flex;
      gap: 20px;
      font-family: "Noto Serif JP", serif;
    }

    nav a { color: white; text-decoration: none; }

    body { padding-top: 70px; }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      pointer-events: none; /* 背景として動かすだけ */
      z-index: -10;
    }

    /* 右下の大きめ六角D-Pad（SVG） */
    .dpad {
      position: fixed;
      right: 20px;
      bottom: 20px;
      width: 260px;
      height: 260px;
      z-index: 1000;
      user-select: none;
      -webkit-user-select: none;
    }
    .dpad svg {
      width: 100%; height: 100%;
      filter: drop-shadow(0 4px 10px rgba(0,0,0,0.25));
    }
    .dpad .wedge {
      fill: #fff;
      stroke: #333;
      stroke-width: 2;
      cursor: pointer;
      transition: fill 0.08s ease;
    }
    .dpad .wedge:hover { fill: #f3f7ff; }
    .dpad .wedge:active { fill: #e8f0ff; }
    .dpad text {
      font-family: system-ui, sans-serif;
      font-size: 24px;
      fill: #111;
      pointer-events: none;
      font-weight: 700;
    }
  </style>
</head>

<body>

<nav>
  <a href="index.html">Home</a>
  <a href="schedule.html">Schedule</a>
  <a href="contact.html">Contact</a>
  <a href="qa.html">Q&A</a>
</nav>

<div class="corner-message" style="position:fixed;top:72px;left:20px;font-size:20px;color:#111;font-weight:bold;z-index:10;pointer-events:none;font-family:'Noto Serif JP',serif;">
  京都府立医科大学 数学研究部 公式HP
</div>

<!-- 右下ヘックスD-Pad（SVG） -->
<div class="dpad" id="dpad">
  <svg viewBox="0 0 260 260" xmlns="http://www.w3.org/2000/svg">
    <!-- 6ウェッジ（三角形）で六角パッドを構成 -->
    <polygon class="wedge" data-dir="r"  points="130,130 240,130 185,34.74" />
    <polygon class="wedge" data-dir="ur" points="130,130 185,225.26 240,130" />
    <polygon class="wedge" data-dir="ul" points="130,130 75,225.26 185,225.26" />
    <polygon class="wedge" data-dir="l"  points="130,130 20,130 75,225.26" />
    <polygon class="wedge" data-dir="dl" points="130,130 75,34.74 20,130" />
    <polygon class="wedge" data-dir="dr" points="130,130 185,34.74 75,34.74" />
    <!-- 矢印ラベル -->
    <text x="205" y="135">→</text>
    <text x="168" y="195">↗</text>
    <text x="92"  y="195">↖</text>
    <text x="55"  y="135">←</text>
    <text x="92"  y="65">↙</text>
    <text x="168" y="65">↘</text>
  </svg>
</div>

<script>
new p5(p => {
  const sideLength = 60;
  const walkerCount = 300;
  let triangles = [];
  let points = [];
  let adjacency = new Map();
  let walkers = [];
  let boosting = false; // 既存は温存（未使用）

  // ===== Safety Areas: 左上(START用)と右下(GOAL用) =====
  let safetyStart = {x:0,y:0,w:0,h:0};
  let safetyGoal  = {x:0,y:0,w:0,h:0};

  function computeSafetyRects(){
    const W = p.width, H = p.height;

    // START側（左上）
    const sw = Math.min(440, Math.max(240, W * 0.34));
    const sh = Math.min(380, Math.max(220, H * 0.28));
    const sx = 24;
    const sy = 110;
    safetyStart = {x:sx, y:sy, w:sw, h:sh};

    // GOAL側（右下）…D-Pad(260x260 @ 20px余白)と干渉しないようにマージン
    const dpadW = 260, dpadH = 260, dpadM = 20;
    const gw = Math.min(440, Math.max(240, W * 0.34));
    const gh = Math.min(380, Math.max(220, H * 0.28));
    const gx = Math.max(20, W - gw - dpadW - dpadM - 20);
    const gy = Math.max(100, H - gh - dpadH - dpadM - 20);
    safetyGoal = {x:gx, y:gy, w:gw, h:gh};
  }

  function insideRect(pt, r){
    return (pt.x >= r.x && pt.x <= r.x + r.w &&
            pt.y >= r.y && pt.y <= r.y + r.h);
  }
  function insideAnySafety(pt){
    return insideRect(pt, safetyStart) || insideRect(pt, safetyGoal);
  }

  // ===== START / GOAL：各Safety内で固定（頂点スナップ） =====
  let startPoint = null, goalPoint = null;

  function nearestVertexInRect(x, y, rect){
    let best = null, bestD = Infinity;
    for (const pt of points){
      if (!insideRect(pt, rect)) continue;
      const d = p.dist(x, y, pt.x, pt.y);
      if (d < bestD){ bestD = d; best = pt; }
    }
    return best;
  }

  function pickStartGoalFixed(){
    // 左上Safetyの左上隅寄り → START
    startPoint = nearestVertexInRect(safetyStart.x + 16, safetyStart.y + 16, safetyStart);
    // 右下Safetyの右下隅寄り → GOAL
    goalPoint  = nearestVertexInRect(safetyGoal.x + safetyGoal.w - 16, safetyGoal.y + safetyGoal.h - 16, safetyGoal);
  }

  // ===== 緑の手動Walker（辺上のみ） =====
  const SQ3 = Math.sqrt(3);
  const DIR = {
    r:  {x:  1.0, y:  0.0},
    ur: {x:  0.5, y: -SQ3/2},
    dr: {x:  0.5, y:  SQ3/2},
    l:  {x: -1.0, y:  0.0},
    ul: {x: -0.5, y: -SQ3/2},
    dl: {x: -0.5, y:  SQ3/2},
  };

  let manualWalker;
  let gameOver = false;
  let gameClear = false;

  class ManualWalker {
    constructor(startVec) {
      this.current = startVec;
      this.next = null;
      this.t = 0;
    }
    isMoving(){ return !!this.next; }
    stepByDirection(dirKey){
      if (this.isMoving() || gameOver || gameClear) return;
      const d = DIR[dirKey];
      const key = this.current.x + "," + this.current.y;
      const nbrs = adjacency.get(key)?.neighbors || [];
      let best = null, bestDot = 0.1;
      for (const n of nbrs){
        const vx = n.x - this.current.x, vy = n.y - this.current.y;
        const dot = vx*d.x + vy*d.y;
        if (dot > bestDot){ bestDot = dot; best = n; }
      }
      if (best){ this.next = best; this.t = 0; }
    }
    update(){
      if (this.next){
        this.t += 0.08;
        if (this.t >= 1){
          this.current = this.next;
          this.next = null;
          this.t = 0;
          // GOAL判定（頂点一致）
          if (goalPoint && this.current.x === goalPoint.x && this.current.y === goalPoint.y){
            gameClear = true;
            p.noLoop();
          }
        }
      }
    }
    getPosition(){
      if (this.next){
        return p.createVector(
          p.lerp(this.current.x, this.next.x, this.t),
          p.lerp(this.current.y, this.next.y, this.t)
        );
      }
      return this.current.copy();
    }
    display(){
      const pos = this.getPosition();
      p.noStroke();
      p.fill(0, 255, 0, 60);
      p.ellipse(pos.x, pos.y, 24);
      p.fill(0, 180, 0);
      p.ellipse(pos.x, pos.y, 8);
    }
  }

  // ===== 既存の黒Walker（Safety両方に侵入禁止） =====
  class Walker {
    constructor() {
      let pt;
      do { pt = p.random(points); } while (insideAnySafety(pt));
      this.current = pt;
      this.next = this.chooseNext(this.current);
      this.t = 0;
      this.baseSpeed = p.random(0.003, 0.008);
      this.phase = p.random(p.TWO_PI);
    }
    chooseNext(current) {
      const key = current.x + ',' + current.y;
      let options = adjacency.get(key)?.neighbors || [];
      options = options.filter(n => !insideAnySafety(n));
      if (!options.length) return current;
      let next;
      do {
        next = p.random(options);
      } while (next.x === current.x && next.y === current.y && options.length > 1);
      return next;
    }
    update() {
      const speedMultiplier = 1;
      this.t += this.baseSpeed * speedMultiplier;
      if (this.t >= 1) {
        this.current = this.next;
        this.next = this.chooseNext(this.current);
        this.t = 0;
      }
    }
    getPosition(){
      return {
        x: p.lerp(this.current.x, this.next.x, this.t),
        y: p.lerp(this.current.y, this.next.y, this.t)
      };
    }
    display() {
      const pos = this.getPosition();
      const size = 6 + p.sin(p.frameCount * 0.05 + this.phase) * 2;
      const glow = 20 + 10 * p.sin(p.frameCount * 0.08 + this.phase);
      p.noStroke();
      p.fill(0, 0, 0, 25);
      p.ellipse(pos.x, pos.y, size + glow);
      p.fill(0);
      p.ellipse(pos.x, pos.y, size);
    }
  }

  // ===== p5: setup =====
  p.setup = () => {
    const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    const cnv = p.createCanvas(p.windowWidth, height);
    cnv.position(0, 0);

    generateTriangleGrid();
    computeSafetyRects();     // 2つのSafetyを計算
    pickStartGoalFixed();     // 各Safety内の固定位置を選ぶ

    walkers = [];
    for (let i = 0; i < walkerCount; i++) walkers.push(new Walker());

    manualWalker = new ManualWalker(startPoint);
    setupDpad();
  };

  // ===== p5: draw =====
  p.draw = () => {
    p.background(255);

    // タイル
    p.noFill();
    p.stroke(0, 40);
    for (let t of triangles) {
      p.beginShape();
      for (let pt of t) p.vertex(pt.x, pt.y);
      p.endShape(p.CLOSE);
    }

    // Safety Areas（START/GOAL）
    drawSafetyAreas();

    // START / GOAL
    drawStartGoal();

    // 黒ウォーカー
    for (let w of walkers) { w.update(); w.display(); }

    // 緑ウォーカー
    manualWalker.update();
    manualWalker.display();

    // 当たり判定
    if (!gameOver && !gameClear && checkCollision()){
      gameOver = true;
      drawBanner("GAME OVER", "#ff2d2d");
      p.noLoop();
      return;
    }

    // CLEARバナー（noLoop後も保持）
    if (gameClear){
      drawBanner("CLEAR!", "#00b86b");
    }
  };

  // ===== 当たり判定 =====
  function checkCollision(){
    const mp = manualWalker.getPosition();
    const threshold = 12;
    for (const w of walkers){
      const pos = w.getPosition();
      if (p.dist(mp.x, mp.y, pos.x, pos.y) < threshold){
        return true;
      }
    }
    return false;
  }

  // ===== Safety描画（2つ） =====
  function drawSafetyAreas(){
    // START側：薄い緑
    p.push();
      p.noStroke();
      p.fill(0, 200, 120, 18);
      p.rect(safetyStart.x, safetyStart.y, safetyStart.w, safetyStart.h, 10);
      p.stroke(0, 160, 110, 120);
      p.noFill();
      p.strokeWeight(1.5);
      p.rect(safetyStart.x, safetyStart.y, safetyStart.w, safetyStart.h, 10);
      p.noStroke();
      p.fill(0,120,80,160);
      p.textSize(12);
      p.text("SAFETY (START)", safetyStart.x + 8, safetyStart.y + 16);
    p.pop();

    // GOAL側：薄い青緑
    p.push();
      p.noStroke();
      p.fill(0, 160, 255, 14);
      p.rect(safetyGoal.x, safetyGoal.y, safetyGoal.w, safetyGoal.h, 10);
      p.stroke(0, 120, 220, 120);
      p.noFill();
      p.strokeWeight(1.5);
      p.rect(safetyGoal.x, safetyGoal.y, safetyGoal.w, safetyGoal.h, 10);
      p.noStroke();
      p.fill(0,120,220,160);
      p.textSize(12);
      p.text("SAFETY (GOAL)", safetyGoal.x + 8, safetyGoal.y + 16);
    p.pop();
  }

  // ===== START / GOAL描画 =====
  function drawStartGoal(){
    if (!startPoint || !goalPoint) return;

    // START（緑リング）
    p.push();
      p.noFill();
      p.stroke(0,180,0,220);
      p.strokeWeight(2);
      p.ellipse(startPoint.x, startPoint.y, 18);
      p.noStroke();
      p.fill(0,180,0,120);
      p.ellipse(startPoint.x, startPoint.y, 6);
      p.fill(0,150,0);
      p.textSize(12);
      p.text("START", startPoint.x + 12, startPoint.y - 10);
    p.pop();

    // GOAL（青パルス）
    const pulse = 22 + 6 * Math.sin(p.frameCount * 0.07);
    p.push();
      p.noFill();
      p.stroke(0,120,255,220);
      p.strokeWeight(2);
      p.ellipse(goalPoint.x, goalPoint.y, pulse);
      p.noStroke();
      p.fill(0,120,255);
      p.ellipse(goalPoint.x, goalPoint.y, 6);
      p.fill(0,120,255);
      p.textSize(12);
      p.text("GOAL", goalPoint.x + 12, goalPoint.y - 10);
    p.pop();
  }

  // ===== バナー（GAME OVER / CLEAR） =====
  function drawBanner(text, color){
    p.push();
      p.textAlign(p.CENTER, p.CENTER);
      p.textSize(64);
      p.fill(color);
      p.noStroke();
      p.text(text, p.width/2, p.height/2);
    p.pop();
  }

  // ===== 格子生成（既存） =====
  function generateTriangleGrid() {
    const h = sideLength * Math.sqrt(3) / 2;
    triangles = [];
    adjacency.clear();

    for (let y = 0; y < p.height + h; y += h) {
      for (let x = 0; x < p.width + sideLength; x += sideLength) {
        const xOffset = (Math.floor(y / h) % 2) * (sideLength / 2);
        const p1 = p.createVector(x + xOffset, y);
        const p2 = p.createVector(x + sideLength / 2 + xOffset, y + h);
        const p3 = p.createVector(x - sideLength / 2 + xOffset, y + h);
        triangles.push([p1, p2, p3]);

        registerEdge(p1, p2);
        registerEdge(p2, p3);
        registerEdge(p3, p1);
      }
    }
    points = Array.from(adjacency.values()).map(obj => obj.vec);
  }
  function registerEdge(a, b) {
    const keyA = a.x + ',' + a.y;
    const keyB = b.x + ',' + b.y;

    if (!adjacency.has(keyA)) adjacency.set(keyA, { vec: a, neighbors: [] });
    if (!adjacency.has(keyB)) adjacency.set(keyB, { vec: b, neighbors: [] });

    const neighborsA = adjacency.get(keyA).neighbors;
    const neighborsB = adjacency.get(keyB).neighbors;

    if (!neighborsA.some(n => n.x === b.x && n.y === b.y)) neighborsA.push(adjacency.get(keyB).vec);
    if (!neighborsB.some(n => n.x === a.x && n.y === a.y)) neighborsB.push(adjacency.get(keyA).vec);
  }

  // ===== D-Padイベント =====
  function setupDpad(){
    const dpad = document.getElementById('dpad');
    const bind = dir => e => { e.preventDefault(); manualWalker.stepByDirection(dir); };
    ['ul','ur','l','r','dl','dr'].forEach(dir=>{
      const el = dpad.querySelector(`.wedge[data-dir="${dir}"]`);
      if (!el) return;
      el.addEventListener('click',      bind(dir), {passive:false});
      el.addEventListener('touchstart', bind(dir), {passive:false});
    });
  }

  // ===== リサイズ =====
  p.windowResized = () => {
    p.resizeCanvas(
      p.windowWidth,
      Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
    );
    generateTriangleGrid();
    computeSafetyRects();
    pickStartGoalFixed();
    manualWalker = new ManualWalker(startPoint);
    gameOver = false; gameClear = false;
    walkers = [];
    for (let i = 0; i < walkerCount; i++) walkers.push(new Walker());
    p.loop();
  };
});
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="ja" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>京都府立医科大学数学研究部 | Math Club</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300..800&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">

  <!-- p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>

  <style>
    /* ===== THEME TOKENS ===== */
    :root{
      --bg:#0b0d12; --fg:#e7e9ee; --muted:#9aa3af;
      --accent:#54d6a3; --accent-2:#5da8ff;
      --glass:rgba(255,255,255,.08); --border:rgba(255,255,255,.18);
      --shadow:0 10px 30px rgba(0,0,0,.35); --card-radius:18px;
      --focus:0 0 0 3px rgba(93,168,255,.35);
    }
    [data-theme="light"]{
      --bg:#f7f8fb; --fg:#0c111a; --muted:#4b5563;
      --accent:#1ea972; --accent-2:#2f7cff;
      --glass:rgba(255,255,255,.7); --border:rgba(17,24,39,.08);
      --shadow:0 10px 30px rgba(0,0,0,.08);
      --focus:0 0 0 3px rgba(47,124,255,.25);
    }

    /* ===== RESET / BASE ===== */
    *{box-sizing:border-box}
    html,body{height:100%;}
    html, body {
      margin:0; padding:0; overflow-x:hidden;
      background:var(--bg); color:var(--fg);
      font-family:"Inter", system-ui, -apple-system, "Noto Serif JP", serif;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
      overscroll-behavior: none;
    }
    a{color:inherit; text-decoration:none}
    a:focus-visible, button:focus-visible{outline:none; box-shadow:var(--focus); border-radius:10px}

    /* ドラッグ中は選択や長押しメニューを抑制 */
    body.dragging, body.dragging *{
      user-select:none; -webkit-user-select:none; -webkit-touch-callout:none;
      cursor: grabbing !important;
    }

    /* ===== BACKGROUND LAYERS ===== */
    .bg-gradient{
      position:fixed; inset:0; z-index:0;
      background:
        radial-gradient(1000px 600px at 15% 20%, rgba(84,214,163,.25), transparent 60%),
        radial-gradient(900px 700px at 85% 70%, rgba(93,168,255,.22), transparent 55%),
        linear-gradient(180deg, var(--bg) 0%, var(--bg) 100%);
    }
    canvas{ position:fixed; inset:0; pointer-events:none; z-index:1; }

    /* ===== NAVBAR ===== */
    nav{
      position:fixed; top:0; left:0; right:0; z-index:10;
      backdrop-filter: blur(12px);
      background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.10)), var(--glass);
      border-bottom:1px solid var(--border);
    }
    .nav-inner{ max-width:1100px; margin:0 auto; display:flex; align-items:center; gap:20px; padding:14px 24px; }
    .brand{ display:flex; align-items:center; gap:12px; font-weight:700; font-family:"Noto Serif JP", serif; letter-spacing:.02em; }
    .brand-badge{ display:inline-grid; place-items:center; width:34px; height:34px; border-radius:10px;
      background:linear-gradient(135deg, var(--accent), var(--accent-2)); color:#fff; font-weight:800; box-shadow:0 6px 18px rgba(0,0,0,.25); }
    .nav-links{ margin-left:auto; display:flex; gap:18px; flex-wrap:wrap; }
    .nav-links a{ padding:8px 10px; border-radius:10px; opacity:.95; }
    .nav-links a:hover{ background:var(--glass); }
    .theme-toggle{ margin-left:6px; border:1px solid var(--border); background:var(--glass); border-radius:12px; padding:8px 12px; cursor:pointer; box-shadow:var(--shadow); font-weight:600; }

    /* ===== LAYOUT ===== */
    main{ padding-top:86px; position:relative; z-index:10; }
    .container{ max-width:1100px; margin:0 auto; padding:28px 24px 64px; }
    .hero{
      position:relative; overflow:hidden; border:1px solid var(--border); border-radius:24px;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); backdrop-filter: blur(10px);
      padding:44px 36px; box-shadow: var(--shadow);
    }
    .hero h1{ margin:0 0 10px; font-size:clamp(26px, 4vw, 40px); font-family:"Noto Serif JP", serif; letter-spacing:.02em; }
    .hero p{ margin:0 0 24px; color:var(--muted); font-size:clamp(14px, 2vw, 16px); }
    .badge{ display:inline-flex; gap:10px; align-items:center; padding:8px 12px; border-radius:999px; font-weight:600;
      background:linear-gradient(135deg, rgba(84,214,163,.2), rgba(93,168,255,.2)); border:1px solid var(--border); margin-bottom:10px; }
    .cta-grid{ display:grid; gap:16px; grid-template-columns:repeat(3, minmax(0,1fr)); }
    @media (max-width:820px){ .cta-grid{ grid-template-columns:1fr; } }
    .card{
      display:block; padding:20px; border-radius:var(--card-radius); border:1px solid var(--border); background:var(--glass);
      backdrop-filter: blur(8px); box-shadow: var(--shadow); transition: transform .2s ease, box-shadow .2s ease, border-color .2s ease;
    }
    .card:hover{ transform: translateY(-2px); border-color: rgba(93,168,255,.45); box-shadow:0 14px 40px rgba(0,0,0,.35); }
    .card h3{ margin:0 0 6px; font-size:18px; }
    .card p{ margin:0; color:var(--muted); font-size:14px; }

    /* 操作ヒント */
    .control-hint{
      position:fixed; right:18px; bottom:18px; z-index:10;
      display:flex; gap:10px; align-items:center; background:var(--glass); border:1px solid var(--border);
      border-radius:12px; padding:10px 12px; backdrop-filter: blur(8px); box-shadow: var(--shadow); font-size:13px; color:var(--muted);
    }
    .dot{ width:10px; height:10px; border-radius:50%; background: radial-gradient(circle at 40% 35%, rgba(0,255,120,.9), rgba(0,255,120,.3)); box-shadow:0 0 18px rgba(0,255,120,.55); }

    .section{ margin-top:28px; display:grid; gap:16px; grid-template-columns:1fr 1fr; }
    .section .panel{ padding:20px; border-radius:var(--card-radius); border:1px solid var(--border); background:var(--glass); backdrop-filter: blur(8px); box-shadow: var(--shadow); }
    @media (max-width:920px){ .section{ grid-template-columns:1fr; } }

    footer{ margin-top:36px; padding:18px; text-align:center; color:var(--muted); font-size:13px; }

    /* ===== START OVERLAY ===== */
    .start-overlay{
      position:fixed; inset:0; z-index:20; display:flex; align-items:center; justify-content:center;
      backdrop-filter: blur(12px);
      background: radial-gradient(40% 35% at 50% 50%, rgba(255,255,255,.12), transparent 60%);
    }
    .start-btn{
      font-family:"Inter","Noto Serif JP",serif; font-weight:800; letter-spacing:.08em;
      padding:18px 28px; border-radius:16px; border:1px solid var(--border);
      background:linear-gradient(135deg, var(--accent), var(--accent-2));
      color:#fff; font-size:22px; cursor:pointer; box-shadow:0 14px 40px rgba(0,0,0,.35);
    }
    .start-btn:active{ transform:translateY(1px); }

    /* ===== GAME-ONLY MODE: 文字の類を全て非表示 ===== */
    body.game-only nav,
    body.game-only main,
    body.game-only .control-hint { display:none !important; }
  </style>
</head>
<body>
  <!-- Background layers -->
  <div class="bg-gradient"></div>

  <!-- START Overlay -->
  <div id="start-overlay" class="start-overlay">
    <button id="startBtn" class="start-btn">GAME START</button>
  </div>

  <!-- NAV -->
  <nav>
    <div class="nav-inner">
      <div class="brand">
        <div class="brand-badge">∑</div>
        <div>京都府立医科大学 数学研究部</div>
      </div>
      <div class="nav-links" role="navigation" aria-label="Main">
        <a href="index.html">Home</a>
        <a href="schedule.html">Schedule</a>
        <a href="contact.html">Contact</a>
        <a href="qa.html">Q&amp;A</a>
        <button class="theme-toggle" onclick="toggleTheme()">Theme</button>
      </div>
    </div>
  </nav>

  <!-- MAIN -->
  <main>
    <div class="container">
      <section class="hero">
        <div class="badge">Official Site</div>
        <h1>京都府立医科大学 数学研究部 公式HP</h1>
        <p>幾何と動きの美しさで数学をもっと身近に。三角タイル上のウォーカーを操作して、<br/>START から GOAL へ。画面をフリック / ドラッグで進行方向を指示できます。</p>
        <div class="cta-grid">
          <a class="card" href="schedule.html"><h3>Schedule</h3><p>例会 / 勉強会 / イベントの予定をチェック。</p></a>
          <a class="card" href="contact.html"><h3>Contact</h3><p>参加希望・見学の希望はこちら。</p></a>
          <a class="card" href="qa.html"><h3>Q&amp;A</h3><p>入部・活動内容・必要スキルetc。</p></a>
        </div>
      </section>

      <section class="section" aria-label="about">
        <div class="panel">
          <h3 style="margin:0 0 8px;font-family:'Noto Serif JP',serif;">活動の目的</h3>
          <p style="margin:0;color:var(--muted);">数学力や基本的なサイエンス力の底上げを図り、医学を多角的に学ぶ。</p>
        </div>
        <div class="panel">
          <h3 style="margin:0 0 8px;font-family:'Noto Serif JP',serif;">Works</h3>
          <p style="margin:0;color:var(--muted);">p5.js / JavaScript / LaTeX / GeoGebra。作品やスライドは定期的に公開予定。</p>
        </div>
      </section>

      <footer>© Kyoto Prefectural University of Medicine Math Club Established in 2024</footer>
    </div>
  </main>

  <!-- 操作ヒント -->
  <div class="control-hint">
    <div class="dot"></div>
    <span>画面をフリック / ドラッグで操作し、Greenの点をGoalに導こう。</span>
  </div>

  <!-- ===== Theme, Start Button Hook & p5.js ===== -->
  <script>
    // 文字非表示フラグ（キャンバス内テキストも含む）
    window.hideCanvasText = false;

    // テーマ切替
    (function(){
      const saved = localStorage.getItem('theme');
      if(saved) document.documentElement.setAttribute('data-theme', saved);
      window.toggleTheme = function(){
        const root = document.documentElement;
        const next = root.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
        root.setAttribute('data-theme', next);
        localStorage.setItem('theme', next);
      }
    })();

    // STARTボタン：押下でゲーム専用モードへ
    (function(){
      const btn = document.getElementById('startBtn');
      const overlay = document.getElementById('start-overlay');
      btn.addEventListener('click', ()=>{
        document.body.classList.add('game-only');  // DOM上の文字UIを全て隠す
        overlay.style.display = 'none';            // オーバーレイも消す
        window.hideCanvasText = true;              // キャンバス上のテキストも非表示に
        // キャンバスをビューポートに最適化
        window.dispatchEvent(new Event('resize'));
      });
    })();

    new p5(p=>{
      const sideLength=60, walkerCount=300, SAFE_RADIUS=20;
      let triangles=[], points=[], adjacency=new Map(), walkers=[];
      let startPoint=null, goalPoint=null, manualWalker;
      let gameOver=false, gameClear=false;
      let trails=[]; // 軌跡
      let waveAnim=null; // CLEAR波紋

      // テーマ状態参照
      const isDark = () => document.documentElement.getAttribute('data-theme') !== 'light';
      const mo = new MutationObserver(()=>{}); mo.observe(document.documentElement, { attributes:true, attributeFilter:['data-theme'] });

      /* ==== Trail / Wave ==== */
      class Trail { constructor(x,y){ this.x=x; this.y=y; this.life=255; } update(){ this.life-=4; } isAlive(){ return this.life>0; }
        display(){ p.noStroke(); p.fill(0,255,100,this.life*0.4); p.ellipse(this.x,this.y,8); } }
      class Wave { constructor(x,y){ this.x=x; this.y=y; this.radius=0; this.life=255; }
        update(){ this.radius+=12; this.life-=4; } isAlive(){ return this.life>0; }
        display(){ p.noFill(); p.stroke(0,180,255,this.life); p.strokeWeight(2); p.ellipse(this.x,this.y,this.radius*2); } }

      /* ==== Manual Walker（緑） ==== */
      class ManualWalker{
        constructor(v){ this.current=v; this.next=null; this.t=0; }
        isMoving(){ return !!this.next; }
        stepByAim(a){
          if(this.isMoving()||gameOver||gameClear)return;
          const rad=a*Math.PI/180, aim={x:Math.cos(rad), y:-Math.sin(rad)};
          const key=this.current.x+","+this.current.y;
          const nbrs=adjacency.get(key)?.neighbors||[];
          let best=null,bestDot=0.1;
          for(const n of nbrs){
            const vx=n.x-this.current.x,vy=n.y-this.current.y,len=Math.hypot(vx,vy)||1;
            const dot=(vx/len)*aim.x+(vy/len)*aim.y;
            if(dot>bestDot){ bestDot=dot; best=n; }
          }
          if(best){ this.next=best; this.t=0; }
        }
        update(){
          if(this.next){
            this.t+=0.08;
            if(this.t>=1){
              this.current=this.next; this.next=null; this.t=0;
              trails.push(new Trail(this.current.x,this.current.y));
              if(goalPoint && this.current.x===goalPoint.x && this.current.y===goalPoint.y){
                gameClear=true; waveAnim=new Wave(goalPoint.x,goalPoint.y);
              }
            }
          }
        }
        getPosition(){
          if(this.next) return p.createVector(p.lerp(this.current.x,this.next.x,this.t),p.lerp(this.current.y,this.next.y,this.t));
          return this.current.copy();
        }
        display(){
          const pos=this.getPosition();
          const glow=22+6*Math.sin(p.frameCount*0.07);
          p.noStroke(); p.fill(0,255,0,40); p.ellipse(pos.x,pos.y,glow);
          p.fill(0,200,80); p.ellipse(pos.x,pos.y,10);
        }
      }

      /* ==== Auto Walkers（白） ==== */
      class Walker{
        constructor(){
          let pt; do{ pt=p.random(points);}while(insideAnySafety(pt));
          this.current=pt; this.next=this.chooseNext(pt); this.t=0;
          this.baseSpeed=p.random(0.003,0.008); this.phase=p.random(p.TWO_PI);
        }
        chooseNext(cur){
          const key=cur.x+","+cur.y;
          let opt=adjacency.get(key)?.neighbors||[];
          opt=opt.filter(n=>!insideAnySafety(n));
          if(!opt.length)return cur;
          let next; do{ next=p.random(opt);}while(next.x===cur.x&&next.y===cur.y&&opt.length>1);
          return next;
        }
        update(){ this.t+=this.baseSpeed; if(this.t>=1){ this.current=this.next; this.next=this.chooseNext(this.current); this.t=0; } }
        getPosition(){ return{x:p.lerp(this.current.x,this.next.x,this.t),y:p.lerp(this.current.y,this.next.y,this.t)}; }
        display(){
          const pos=this.getPosition();
          const size=5 + p.sin(p.frameCount*0.05 + this.phase)*2;
          const glow=18 + 10*p.sin(p.frameCount*0.08 + this.phase);
          const dark = isDark();
          p.noStroke();
          p.fill(255,255,255, dark ? 42 : 28);
          p.ellipse(pos.x, pos.y, size + glow);
          if (dark){
            p.fill(255); p.ellipse(pos.x, pos.y, size);
          } else {
            p.fill(255); p.stroke(0,0,0,60); p.strokeWeight(0.9);
            p.ellipse(pos.x, pos.y, size); p.noStroke();
          }
        }
      }

      /* ==== p5 lifecycle ==== */
      p.setup=()=>{
        const h=Math.max(document.body.scrollHeight,document.documentElement.scrollHeight);
        const cnv=p.createCanvas(p.windowWidth,h); cnv.position(0,0);
        generateTriangleGrid(); pickStartGoalFixed();
        for(let i=0;i<walkerCount;i++) walkers.push(new Walker());
        manualWalker=new ManualWalker(startPoint);
        setupFlickControls();
      };

      p.windowResized=()=>{
        const h=Math.max(window.innerHeight, document.body.scrollHeight, document.documentElement.scrollHeight);
        p.resizeCanvas(p.windowWidth,h);
        triangles=[]; points=[]; adjacency.clear();
        generateTriangleGrid(); pickStartGoalFixed();
      };

      p.draw=()=>{
        p.clear(); // 透明背景
        // 三角タイル：テーマで線色切替
        p.noFill(); p.strokeWeight(1);
        if (isDark()) { p.stroke(255,28); } else { p.stroke(0,40); }
        for(const t of triangles){ p.beginShape(); for(const pt of t)p.vertex(pt.x,pt.y); p.endShape(p.CLOSE); }

        drawStartGoal();

        for(const w of walkers){ w.update(); w.display(); }

        trails.forEach(t=>t.update());
        trails=trails.filter(t=>t.isAlive());
        trails.forEach(t=>t.display());

        manualWalker.update();
        manualWalker.display();

        if(!gameOver&&!gameClear&&checkCollision()){
          gameOver=true; if(!window.hideCanvasText){ drawBanner("GAME OVER","#ff2d2d"); } p.noLoop(); return;
        }
        if(gameClear && waveAnim){
          waveAnim.update(); waveAnim.display();
          if(!waveAnim.isAlive()){ if(!window.hideCanvasText){ drawBanner("CLEAR!","#00b86b"); } }
        }
      };

      /* ==== helpers ==== */
      function pickStartGoalFixed(){ startPoint=nearestVertex(60,250); goalPoint=nearestVertex(p.width-300,p.height-300); }
      function nearestVertex(x,y){ let best=null,bestD=1e9; for(const pt of points){ const d=p.dist(x,y,pt.x,pt.y); if(d<bestD){bestD=d;best=pt;} } return best; }
      function insideAnySafety(pt){ return (p.dist(pt.x,pt.y,startPoint.x,startPoint.y)<=SAFE_RADIUS)||(p.dist(pt.x,pt.y,goalPoint.x,goalPoint.y)<=SAFE_RADIUS); }
      function drawStartGoal(){
        // START circle
        p.stroke(0,220,120,220); p.noFill(); p.ellipse(startPoint.x,startPoint.y,18);
        if(!window.hideCanvasText){ p.noStroke(); p.fill(140,255,200); p.text("START",startPoint.x+12,startPoint.y-10); }
        // GOAL circle (pulse)
        const pulse=22+6*Math.sin(p.frameCount*0.07);
        p.noFill(); p.stroke(100,170,255,230); p.ellipse(goalPoint.x,goalPoint.y,pulse);
        if(!window.hideCanvasText){ p.noStroke(); p.fill(150,200,255); p.text("GOAL",goalPoint.x+12,goalPoint.y-10); }
      }
      function checkCollision(){
        const mp=manualWalker.getPosition();
        for(const w of walkers){ const pos=w.getPosition(); if(p.dist(mp.x,mp.y,pos.x,pos.y)<12)return true; }
        return false;
      }
      function drawBanner(txt,c){ if(window.hideCanvasText) return; p.textAlign(p.CENTER,p.CENTER); p.textSize(64); p.fill(c); p.text(txt,p.width/2,p.height/2); }

      function generateTriangleGrid(){
        const h=sideLength*Math.sqrt(3)/2; triangles=[]; adjacency.clear();
        for(let y=0;y<p.height+h;y+=h){
          for(let x=0;x<p.width+sideLength;x+=sideLength){
            const xOffset=(Math.floor(y/h)%2)*(sideLength/2);
            const p1=p.createVector(x+xOffset,y), p2=p.createVector(x+sideLength/2+xOffset,y+h), p3=p.createVector(x-sideLength/2+xOffset,y+h);
            triangles.push([p1,p2,p3]); registerEdge(p1,p2); registerEdge(p2,p3); registerEdge(p3,p1);
          }
        }
        points=Array.from(adjacency.values()).map(o=>o.vec);
      }
      function registerEdge(a,b){
        const ka=a.x+","+a.y,kb=b.x+","+b.y;
        if(!adjacency.has(ka))adjacency.set(ka,{vec:a,neighbors:[]});
        if(!adjacency.has(kb))adjacency.set(kb,{vec:b,neighbors:[]});
        const A=adjacency.get(ka).neighbors,B=adjacency.get(kb).neighbors;
        if(!A.some(n=>n.x===b.x&&n.y===b.y))A.push(adjacency.get(kb).vec);
        if(!B.some(n=>n.x===a.x&&n.y===a.y))B.push(adjacency.get(ka).vec);
      }

      function setupFlickControls(){
        let startX=0,startY=0,endX=0,endY=0;
        let dragging=false, mouseDown=false;
        const threshold=40, blockThreshold=12;
        const getAngle=(dx,dy)=>{let ang=Math.atan2(-dy,dx)*180/Math.PI;if(ang<0)ang+=360;return ang;};

        // Touch
        window.addEventListener("touchstart",e=>{ const t=e.touches[0]; startX=t.clientX; startY=t.clientY; dragging=false; },{passive:true});
        window.addEventListener("touchmove",e=>{
          const t=e.touches[0]; const dx=t.clientX-startX, dy=t.clientY-startY;
          if(!dragging && Math.hypot(dx,dy)>=blockThreshold){ dragging=true; document.body.classList.add('dragging'); }
          if(dragging){ e.preventDefault(); }
        },{passive:false});
        window.addEventListener("touchend",e=>{
          const t=e.changedTouches[0]; endX=t.clientX; endY=t.clientY;
          const dx=endX-startX, dy=endY-startY;
          if(Math.hypot(dx,dy)>=threshold){ const ang=getAngle(dx,dy); const snapped=Math.round(ang/60)*60%360; manualWalker.stepByAim(snapped); }
          dragging=false; document.body.classList.remove('dragging');
        });

        // Mouse
        window.addEventListener("mousedown",e=>{ mouseDown=true; startX=e.clientX; startY=e.clientY; dragging=false; });
        window.addEventListener("mousemove",e=>{
          if(!mouseDown) return;
          const dx=e.clientX-startX, dy=e.clientY-startY;
          if(!dragging && Math.hypot(dx,dy)>=blockThreshold){ dragging=true; document.body.classList.add('dragging'); }
          if(dragging){ e.preventDefault(); }
        });
        window.addEventListener("mouseup",e=>{
          if(!mouseDown) return; mouseDown=false;
          endX=e.clientX; endY=e.clientY;
          const dx=endX-startX, dy=endY-startY;
          if(Math.hypot(dx,dy)>=threshold){ const ang=getAngle(dx,dy); const snapped=Math.round(ang/60)*60%360; manualWalker.stepByAim(snapped); }
          dragging=false; document.body.classList.remove('dragging');
        });
        window.addEventListener("mouseleave",()=>{ mouseDown=false; dragging=false; document.body.classList.remove('dragging'); });
      }
    });
  </script>
</body>
</html>

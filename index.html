<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>京都府立医科大学数学研究部 | Math Club</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    html, body { margin:0; padding:0; background:#fff; overflow:hidden; font-family:sans-serif; }
    nav {
      position:fixed; top:0; left:0; width:100%;
      background:#111; color:#fff; padding:12px 24px; z-index:999;
      font-size:18px; display:flex; gap:20px; font-family:"Noto Serif JP",serif;
    }
    nav a { color:#fff; text-decoration:none; }
    body { padding-top:70px; }
    canvas { position:fixed; top:0; left:0; pointer-events:none; z-index:-10; }
  </style>
</head>
<body>
  <nav>
    <a href="index.html">Home</a>
    <a href="schedule.html">Schedule</a>
    <a href="contact.html">Contact</a>
    <a href="qa.html">Q&A</a>
  </nav>

  <div class="corner-message" style="position:fixed;top:72px;left:20px;font-size:20px;color:#111;font-weight:bold;z-index:10;pointer-events:none;font-family:'Noto Serif JP',serif;">
    京都府立医科大学 数学研究部 公式HP
  </div>

  <script>
  new p5(p=>{
    const sideLength=60, walkerCount=300, SAFE_RADIUS=20;
    let triangles=[], points=[], adjacency=new Map(), walkers=[];
    let startPoint=null, goalPoint=null, manualWalker;
    let gameOver=false, gameClear=false;
    let waveAnim=null;

    // === Clear Wave ===
    class Wave {
      constructor(x,y){ this.x=x; this.y=y; this.radius=0; this.life=255; }
      update(){ this.radius+=12; this.life-=4; }
      isAlive(){ return this.life>0; }
      display(){
        p.noFill(); p.stroke(0,180,255,this.life); p.strokeWeight(2);
        p.ellipse(this.x,this.y,this.radius*2);
      }
    }

    // === Manual Walker ===
    class ManualWalker{
      constructor(v){
        this.current=v; this.next=null; this.t=0;
        this.trail=[];       // ← comet tail points
        this.maxTrail=30;    // ← 尾の長さ
      }
      isMoving(){ return !!this.next; }
      stepByAim(a){
        if(this.isMoving()||gameOver||gameClear)return;
        const rad=a*Math.PI/180, aim={x:Math.cos(rad), y:-Math.sin(rad)};
        const key=this.current.x+","+this.current.y;
        const nbrs=adjacency.get(key)?.neighbors||[];
        let best=null,bestDot=0.1;
        for(const n of nbrs){
          const vx=n.x-this.current.x,vy=n.y-this.current.y,len=Math.hypot(vx,vy)||1;
          const dot=(vx/len)*aim.x+(vy/len)*aim.y;
          if(dot>bestDot){ bestDot=dot; best=n; }
        }
        if(best){ this.next=best; this.t=0; }
      }
      update(){
        // move
        if(this.next){
          this.t+=0.08;
          if(this.t>=1){
            this.current=this.next;
            this.next=null;
            this.t=0;
            if(goalPoint && this.current.x===goalPoint.x && this.current.y===goalPoint.y){
              gameClear=true;
              waveAnim=new Wave(goalPoint.x,goalPoint.y);
            }
          }
        }
        // add current position to trail
        const pos=this.getPosition();
        this.trail.push({x:pos.x,y:pos.y});
        if(this.trail.length>this.maxTrail)this.trail.shift();
      }
      getPosition(){
        if(this.next)
          return p.createVector(p.lerp(this.current.x,this.next.x,this.t),p.lerp(this.current.y,this.next.y,this.t));
        return this.current.copy();
      }
      display(){
        // --- comet tail ---
        if(this.trail.length>1){
          for(let i=0;i<this.trail.length-1;i++){
            const a=this.trail[i], b=this.trail[i+1];
            const alpha=p.map(i,0,this.trail.length-1,40,180);
            const w=p.map(i,0,this.trail.length-1,1,6);
            p.stroke(0,255,120,alpha);
            p.strokeWeight(w);
            p.line(a.x,a.y,b.x,b.y);
          }
        }
        // --- head ---
        const pos=this.getPosition();
        p.noStroke(); p.fill(0,255,0); p.ellipse(pos.x,pos.y,10);
        p.fill(0,255,120,60); p.ellipse(pos.x,pos.y,20);
      }
    }

    // === Auto walkers ===
    class Walker{
      constructor(){
        let pt; do{ pt=p.random(points);}while(insideAnySafety(pt));
        this.current=pt; this.next=this.chooseNext(pt); this.t=0;
        this.baseSpeed=p.random(0.003,0.008); this.phase=p.random(p.TWO_PI);
      }
      chooseNext(cur){
        const key=cur.x+","+cur.y;
        let opt=adjacency.get(key)?.neighbors||[];
        opt=opt.filter(n=>!insideAnySafety(n));
        if(!opt.length)return cur;
        let next;
        do{ next=p.random(opt);}while(next.x===cur.x&&next.y===cur.y&&opt.length>1);
        return next;
      }
      update(){ this.t+=this.baseSpeed; if(this.t>=1){ this.current=this.next; this.next=this.chooseNext(this.current); this.t=0; } }
      getPosition(){ return{x:p.lerp(this.current.x,this.next.x,this.t),y:p.lerp(this.current.y,this.next.y,this.t)}; }
      display(){
        const pos=this.getPosition();
        const size=6+p.sin(p.frameCount*0.05+this.phase)*2;
        const glow=20+10*p.sin(p.frameCount*0.08+this.phase);
        p.noStroke(); p.fill(0,0,0,25); p.ellipse(pos.x,pos.y,size+glow);
        p.fill(0); p.ellipse(pos.x,pos.y,size);
      }
    }

    p.setup=()=>{
      const h=Math.max(document.body.scrollHeight,document.documentElement.scrollHeight);
      const cnv=p.createCanvas(p.windowWidth,h); cnv.position(0,0);
      generateTriangleGrid(); pickStartGoalFixed();
      for(let i=0;i<walkerCount;i++) walkers.push(new Walker());
      manualWalker=new ManualWalker(startPoint);
      setupFlickControls();
    };

    p.draw=()=>{
      p.background(255);
      p.noFill(); p.stroke(0,40);
      for(const t of triangles){ p.beginShape(); for(const pt of t)p.vertex(pt.x,pt.y); p.endShape(p.CLOSE); }

      drawStartGoal();
      for(const w of walkers){ w.update(); w.display(); }

      manualWalker.update();
      manualWalker.display();

      if(!gameOver&&!gameClear&&checkCollision()){
        gameOver=true; drawBanner("GAME OVER","#ff2d2d"); p.noLoop(); return;
      }

      if(gameClear && waveAnim){
        waveAnim.update(); waveAnim.display();
        if(!waveAnim.isAlive()){ drawBanner("CLEAR!","#00b86b"); }
      }
    };

    function pickStartGoalFixed(){
      startPoint=nearestVertex(60,250);
      goalPoint=nearestVertex(p.width-300,p.height-300);
    }
    function nearestVertex(x,y){ let best=null,bestD=1e9; for(const pt of points){ const d=p.dist(x,y,pt.x,pt.y); if(d<bestD){bestD=d;best=pt;} } return best; }
    function insideAnySafety(pt){ return (p.dist(pt.x,pt.y,startPoint.x,startPoint.y)<=SAFE_RADIUS)||(p.dist(pt.x,pt.y,goalPoint.x,goalPoint.y)<=SAFE_RADIUS); }
    function drawStartGoal(){
      p.stroke(0,180,0,220); p.noFill(); p.ellipse(startPoint.x,startPoint.y,18);
      p.noStroke(); p.fill(0,180,0); p.text("START",startPoint.x+12,startPoint.y-10);
      const pulse=22+6*Math.sin(p.frameCount*0.07);
      p.noFill(); p.stroke(0,120,255,220); p.ellipse(goalPoint.x,goalPoint.y,pulse);
      p.noStroke(); p.fill(0,120,255); p.text("GOAL",goalPoint.x+12,goalPoint.y-10);
    }
    function checkCollision(){
      const mp=manualWalker.getPosition();
      for(const w of walkers){ const pos=w.getPosition(); if(p.dist(mp.x,mp.y,pos.x,pos.y)<12)return true; }
      return false;
    }
    function drawBanner(txt,c){ p.textAlign(p.CENTER,p.CENTER); p.textSize(64); p.fill(c); p.text(txt,p.width/2,p.height/2); }

    function generateTriangleGrid(){
      const h=sideLength*Math.sqrt(3)/2; triangles=[]; adjacency.clear();
      for(let y=0;y<p.height+h;y+=h){
        for(let x=0;x<p.width+sideLength;x+=sideLength){
          const xOffset=(Math.floor(y/h)%2)*(sideLength/2);
          const p1=p.createVector(x+xOffset,y), p2=p.createVector(x+sideLength/2+xOffset,y+h), p3=p.createVector(x-sideLength/2+xOffset,y+h);
          triangles.push([p1,p2,p3]); registerEdge(p1,p2); registerEdge(p2,p3); registerEdge(p3,p1);
        }
      }
      points=Array.from(adjacency.values()).map(o=>o.vec);
    }
    function registerEdge(a,b){
      const ka=a.x+","+a.y,kb=b.x+","+b.y;
      if(!adjacency.has(ka))adjacency.set(ka,{vec:a,neighbors:[]});
      if(!adjacency.has(kb))adjacency.set(kb,{vec:b,neighbors:[]});
      const A=adjacency.get(ka).neighbors,B=adjacency.get(kb).neighbors;
      if(!A.some(n=>n.x===b.x&&n.y===b.y))A.push(adjacency.get(kb).vec);
      if(!B.some(n=>n.x===a.x&&n.y===a.y))B.push(adjacency.get(ka).vec);
    }

    function setupFlickControls(){
      let startX=0,startY=0,endX=0,endY=0;
      const threshold=40;
      const getAngle=(dx,dy)=>{let ang=Math.atan2(-dy,dx)*180/Math.PI;if(ang<0)ang+=360;return ang;};

      window.addEventListener("touchstart",e=>{const t=e.touches[0];startX=t.clientX;startY=t.clientY;},{passive:true});
      window.addEventListener("touchend",e=>{
        const t=e.changedTouches[0];endX=t.clientX;endY=t.clientY;
        const dx=endX-startX,dy=endY-startY;
        if(Math.hypot(dx,dy)<threshold)return;
        const ang=getAngle(dx,dy);const snapped=Math.round(ang/60)*60%360;
        manualWalker.stepByAim(snapped);
      },{passive:true});

      let mouseDown=false;
      window.addEventListener("mousedown",e=>{mouseDown=true;startX=e.clientX;startY=e.clientY;});
      window.addEventListener("mouseup",e=>{
        if(!mouseDown)return;mouseDown=false;
        endX=e.clientX;endY=e.clientY;
        const dx=endX-startX,dy=endY-startY;
        if(Math.hypot(dx,dy)<threshold)return;
        const ang=getAngle(dx,dy);const snapped=Math.round(ang/60)*60%360;
        manualWalker.stepByAim(snapped);
      });
    }
  });
  </script>
</body>
</html>

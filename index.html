<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>京都府立医科大学数学研究部 | Math Club</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background: white;
      overflow-x: hidden;
    }

    nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: #111;
      color: white;
      padding: 12px 24px;
      z-index: 999;
      font-size: 18px;
      display: flex;
      gap: 20px;
      font-family: "Noto Serif JP", serif;
    }

    nav a { color: white; text-decoration: none; }

    body { padding-top: 70px; }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      pointer-events: none; /* 背景として動かすだけ */
      z-index: -10;
    }

    /* 右下のヘックスD-Pad */
    .dpad {
      position: fixed;
      right: 20px;
      bottom: 20px;
      width: 260px;
      height: 260px;
      z-index: 1000;
      user-select: none;
      -webkit-user-select: none;
    }
    .dpad svg {
      width: 100%; height: 100%;
      filter: drop-shadow(0 4px 10px rgba(0,0,0,0.25));
    }
    .dpad .wedge {
      fill: #ffffff;
      stroke: #333;
      stroke-width: 2;
      cursor: pointer;
      transition: fill 0.1s ease;
    }
    .dpad .wedge:hover { fill: #f3f7ff; }
    .dpad .wedge:active { fill: #e8f0ff; }
    .dpad text {
      font-family: system-ui, sans-serif;
      font-size: 24px;
      fill: #111;
      pointer-events: none;
      font-weight: 700;
    }
  </style>
</head>

<body>

<nav>
  <a href="index.html">Home</a>
  <a href="schedule.html">Schedule</a>
  <a href="contact.html">Contact</a>
  <a href="qa.html">Q&A</a>
</nav>

<div class="corner-message" style="position:fixed;top:72px;left:20px;font-size:20px;color:#111;font-weight:bold;z-index:10;pointer-events:none;font-family:'Noto Serif JP',serif;">
  京都府立医科大学 数学研究部 公式HP
</div>

<!-- 右下ヘックスD-Pad（SVG） -->
<div class="dpad" id="dpad">
  <svg viewBox="0 0 260 260" xmlns="http://www.w3.org/2000/svg">
    <!-- 中心 -->
    <defs>
      <g id="wedge-shape">
        <!-- 正六角形中心(130,130), 半径110。中心+隣接頂点2つの三角形で1ウェッジ -->
      </g>
    </defs>
    <!-- 頂点（事前計算） -->
    <!-- 角度: 0, 60, 120, 180, 240, 300 度 -->
    <!-- 中心 -->
    <g id="wedge-group">
      <!-- r (0°) : center -> v300 -> v0 -->
      <polygon class="wedge" data-dir="r"
        points="130,130 185,34.74 240,130" />
      <!-- ur (60°): center -> v0 -> v60 -->
      <polygon class="wedge" data-dir="ur"
        points="130,130 240,130 185,225.26" />
      <!-- ul (120°): center -> v60 -> v120 -->
      <polygon class="wedge" data-dir="ul"
        points="130,130 185,225.26 75,225.26" />
      <!-- l (180°): center -> v120 -> v180 -->
      <polygon class="wedge" data-dir="l"
        points="130,130 75,225.26 20,130" />
      <!-- dl (240°): center -> v180 -> v240 -->
      <polygon class="wedge" data-dir="dl"
        points="130,130 20,130 75,34.74" />
      <!-- dr (300°): center -> v240 -> v300 -->
      <polygon class="wedge" data-dir="dr"
        points="130,130 75,34.74 185,34.74" />
    </g>

    <!-- 矢印ラベル（中心から半径75付近） -->
    <text x="205" y="135">→</text>     <!-- r -->
    <text x="168" y="195">↗</text>     <!-- ur -->
    <text x="92"  y="195">↖</text>     <!-- ul -->
    <text x="55"  y="135">←</text>     <!-- l -->
    <text x="92"  y="65">↙</text>      <!-- dl -->
    <text x="168" y="65">↘</text>      <!-- dr -->
  </svg>
</div>

<script>
new p5(p => {
  const sideLength = 60;
  const walkerCount = 300;
  let triangles = [];
  let points = [];
  let adjacency = new Map();
  let walkers = [];
  let boosting = false; // 既存変数は温存

  // ====== 追加: 安全ゾーンとゲーム状態 ======
  let safetyRect = {x:0, y:0, w:0, h:0}; // 黒は侵入不可
  let startPoint = null;
  let goalPoint  = null;
  let gameOver = false;
  let gameClear = false;

  // ====== 手動の緑点 ======
  let manualWalker;

  const SQ3 = Math.sqrt(3);
  const DIR = {
    r:  {x:  1.0, y:  0.0},
    ur: {x:  0.5, y: -SQ3/2},
    dr: {x:  0.5, y:  SQ3/2},
    l:  {x: -1.0, y:  0.0},
    ul: {x: -0.5, y: -SQ3/2},
    dl: {x: -0.5, y:  SQ3/2},
  };

  class ManualWalker {
    constructor(startVec) {
      this.current = startVec;
      this.next = null;
      this.t = 0;
    }
    isMoving(){ return !!this.next; }

    stepByDirection(dirKey){
      if (this.isMoving() || gameOver || gameClear) return;
      const d = DIR[dirKey];
      const key = this.current.x + "," + this.current.y;
      const nbrs = adjacency.get(key)?.neighbors || [];
      let best = null;
      let bestDot = 0.1;
      for (const n of nbrs){
        const vx = n.x - this.current.x;
        const vy = n.y - this.current.y;
        const dot = vx*d.x + vy*d.y;
        if (dot > bestDot){
          bestDot = dot;
          best = n;
        }
      }
      if (best){
        this.next = best;
        this.t = 0;
      }
    }

    update(){
      if (this.next){
        this.t += 0.08;
        if (this.t >= 1){
          this.current = this.next;
          this.next = null;
          this.t = 0;
          // GOAL判定（頂点一致でOK）
          if (goalPoint && this.current.x === goalPoint.x && this.current.y === goalPoint.y){
            gameClear = true;
            p.noLoop();
          }
        }
      }
    }

    getPosition(){
      if (this.next){
        return p.createVector(
          p.lerp(this.current.x, this.next.x, this.t),
          p.lerp(this.current.y, this.next.y, this.t)
        );
      }
      return this.current.copy();
    }

    display(){
      const pos = this.getPosition();
      p.noStroke();
      p.fill(0, 255, 0, 60);
      p.ellipse(pos.x, pos.y, 24);
      p.fill(0, 180, 0);
      p.ellipse(pos.x, pos.y, 8);
    }
  }

  class Walker {
    constructor() {
      // 安全ゾーン外から開始
      let pt;
      do { pt = p.random(points); } while (insideSafety(pt));
      this.current = pt;
      this.next = this.chooseNext(this.current);
      this.t = 0;
      this.baseSpeed = p.random(0.003, 0.008);
      this.phase = p.random(p.TWO_PI);
    }
    chooseNext(current) {
      const key = current.x + ',' + current.y;
      let options = adjacency.get(key)?.neighbors || [];
      // 安全ゾーン内には入らない
      options = options.filter(n => !insideSafety(n));
      if (!options.length) return current;
      let next;
      do {
        next = p.random(options);
      } while (next.x === current.x && next.y === current.y && options.length > 1);
      return next;
    }
    update() {
      const speedMultiplier = 1;
      this.t += this.baseSpeed * speedMultiplier;
      if (this.t >= 1) {
        this.current = this.next;
        this.next = this.chooseNext(this.current);
        this.t = 0;
      }
    }
    getPosition(){
      return {
        x: p.lerp(this.current.x, this.next.x, this.t),
        y: p.lerp(this.current.y, this.next.y, this.t)
      };
    }
    display() {
      const pos = this.getPosition();
      const size = 6 + p.sin(p.frameCount * 0.05 + this.phase) * 2;
      const glow = 20 + 10 * p.sin(p.frameCount * 0.08 + this.phase);
      p.noStroke();
      p.fill(0, 0, 0, 25);
      p.ellipse(pos.x, pos.y, size + glow);
      p.fill(0);
      p.ellipse(pos.x, pos.y, size);
    }
  }

  p.setup = () => {
    const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    const cnv = p.createCanvas(p.windowWidth, height);
    cnv.position(0, 0);

    generateTriangleGrid();
    computeSafetyRect();     // 安全ゾーン決定
    pickStartAndGoalFixed(); // 安全ゾーン内で固定配置

    // 黒ウォーカー
    for (let i = 0; i < walkerCount; i++) {
      walkers.push(new Walker());
    }

    // 緑ウォーカー（STARTへ）
    manualWalker = new ManualWalker(startPoint);

    // D-Padにイベント付与
    setupDpad();
  };

  p.draw = () => {
    p.background(255);

    // タイル
    p.noFill();
    p.stroke(0, 40);
    for (let t of triangles) {
      p.beginShape();
      for (let pt of t) p.vertex(pt.x, pt.y);
      p.endShape(p.CLOSE);
    }

    // Safety Area（薄緑）
    drawSafety();

    // START/GOAL
    drawStartGoal();

    // 黒ウォーカー
    for (let w of walkers) {
      w.update();
      w.display();
    }

    // 緑ウォーカー
    manualWalker.update();
    manualWalker.display();

    // 当たり判定（ゲームオーバー）
    if (!gameOver && !gameClear && checkCollision()){
      gameOver = true;
      drawBanner("GAME OVER", "#ff2d2d");
      p.noLoop();
      return;
    }

    // クリア時のバナー（noLoop後も一応表示維持のため）
    if (gameClear){
      drawBanner("CLEAR!", "#00b86b");
    }
  };

  // ====== 当たり判定 ======
  function checkCollision(){
    const mp = manualWalker.getPosition();
    const threshold = 12;
    for (const w of walkers){
      const pos = w.getPosition();
      if (p.dist(mp.x, mp.y, pos.x, pos.y) < threshold){
        return true;
      }
    }
    return false;
  }

  // ====== Safety Area ======
  function computeSafetyRect(){
    // 画面に対して適度なサイズ（中央やや左寄り）
    const W = p.width, H = p.height;
    const w = Math.min(500, Math.max(260, W * 0.42));
    const h = Math.min(500, Math.max(260, H * 0.42));
    const x = Math.max(20, W * 0.12);
    const y = Math.max(100, H * 0.2);
    safetyRect = {x, y, w, h};
  }
  function insideSafety(vec){
    return (vec.x >= safetyRect.x && vec.x <= safetyRect.x + safetyRect.w &&
            vec.y >= safetyRect.y && vec.y <= safetyRect.y + safetyRect.h);
  }
  function drawSafety(){
    p.push();
      p.noStroke();
      p.fill(0, 200, 120, 18);
      p.rect(safetyRect.x, safetyRect.y, safetyRect.w, safetyRect.h, 10);
      p.stroke(0, 160, 110, 120);
      p.noFill();
      p.strokeWeight(1.5);
      p.rect(safetyRect.x, safetyRect.y, safetyRect.w, safetyRect.h, 10);
      p.noStroke();
      p.fill(0,120,80,160);
      p.textSize(12);
      p.text("SAFETY", safetyRect.x + 8, safetyRect.y + 16);
    p.pop();
  }

  // ====== START / GOAL ======
  function pickStartAndGoalFixed(){
    // ゾーン左上寄り→START, 右下寄り→GOAL に最も近い頂点を選ぶ
    const sx = safetyRect.x + 16, sy = safetyRect.y + 16;
    const gx = safetyRect.x + safetyRect.w - 16, gy = safetyRect.y + safetyRect.h - 16;
    startPoint = nearestVertexWithin(sx, sy, true);
    goalPoint  = nearestVertexWithin(gx, gy, true);
  }
  function nearestVertexWithin(x, y, enforceInside){
    let best = null, bestD = Infinity;
    for (const pt of points){
      if (enforceInside && !insideSafety(pt)) continue;
      const d = p.dist(x, y, pt.x, pt.y);
      if (d < bestD){ bestD = d; best = pt; }
    }
    return best;
  }
  function drawStartGoal(){
    if (!startPoint || !goalPoint) return;

    // START（緑）
    p.push();
      p.noFill();
      p.stroke(0,180,0,220);
      p.strokeWeight(2);
      p.ellipse(startPoint.x, startPoint.y, 18);
      p.noStroke();
      p.fill(0,180,0,120);
      p.ellipse(startPoint.x, startPoint.y, 6);
      p.fill(0,150,0);
      p.textSize(12);
      p.text("START", startPoint.x + 12, startPoint.y - 10);
    p.pop();

    // GOAL（青パルス）
    const pulse = 22 + 6 * Math.sin(p.frameCount * 0.07);
    p.push();
      p.noFill();
      p.stroke(0,120,255,220);
      p.strokeWeight(2);
      p.ellipse(goalPoint.x, goalPoint.y, pulse);
      p.noStroke();
      p.fill(0,120,255);
      p.ellipse(goalPoint.x, goalPoint.y, 6);
      p.fill(0,120,255);
      p.textSize(12);
      p.text("GOAL", goalPoint.x + 12, goalPoint.y - 10);
    p.pop();
  }

  // ====== バナー（GAME OVER / CLEAR） ======
  function drawBanner(text, color){
    p.push();
      p.textAlign(p.CENTER, p.CENTER);
      p.textSize(64);
      p.fill(color);
      p.noStroke();
      p.text(text, p.width/2, p.height/2);
    p.pop();
  }

  // ====== 三角タイル生成（既存） ======
  function generateTriangleGrid() {
    const h = sideLength * Math.sqrt(3) / 2;
    triangles = [];
    adjacency.clear();

    for (let y = 0; y < p.height + h; y += h) {
      for (let x = 0; x < p.width + sideLength; x += sideLength) {
        const xOffset = (Math.floor(y / h) % 2) * (sideLength / 2);
        const p1 = p.createVector(x + xOffset, y);
        const p2 = p.createVector(x + sideLength / 2 + xOffset, y + h);
        const p3 = p.createVector(x - sideLength / 2 + xOffset, y + h);
        triangles.push([p1, p2, p3]);

        registerEdge(p1, p2);
        registerEdge(p2, p3);
        registerEdge(p3, p1);
      }
    }
    points = Array.from(adjacency.values()).map(obj => obj.vec);
  }
  function registerEdge(a, b) {
    const keyA = a.x + ',' + a.y;
    const keyB = b.x + ',' + b.y;

    if (!adjacency.has(keyA)) adjacency.set(keyA, { vec: a, neighbors: [] });
    if (!adjacency.has(keyB)) adjacency.set(keyB, { vec: b, neighbors: [] });

    const neighborsA = adjacency.get(keyA).neighbors;
    const neighborsB = adjacency.get(keyB).neighbors;

    if (!neighborsA.some(n => n.x === b.x && n.y === b.y)) neighborsA.push(adjacency.get(keyB).vec);
    if (!neighborsB.some(n => n.x === a.x && n.y === a.y)) neighborsB.push(adjacency.get(keyA).vec);
  }

  // ====== D-Padイベント ======
  function setupDpad(){
    const dpad = document.getElementById('dpad');
    const bind = dir => e => {
      e.preventDefault();
      manualWalker.stepByDirection(dir);
    };
    ['ul','ur','l','r','dl','dr'].forEach(dir=>{
      const el = dpad.querySelector(`.wedge[data-dir="${dir}"]`);
      if (!el) return;
      el.addEventListener('click',      bind(dir), {passive:false});
      el.addEventListener('touchstart', bind(dir), {passive:false});
    });
  }

  // ====== リサイズ ======
  p.windowResized = () => {
    p.resizeCanvas(
      p.windowWidth,
      Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
    );
    // 再生成
    generateTriangleGrid();
    computeSafetyRect();
    pickStartAndGoalFixed();
    manualWalker = new ManualWalker(startPoint);
    gameOver = false;
    gameClear = false;
    walkers = [];
    for (let i = 0; i < walkerCount; i++) walkers.push(new Walker());
    p.loop();
  };
});
</script>

</body>
</html>

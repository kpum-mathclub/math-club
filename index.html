<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>京都府立医科大学数学研究部 | Math Club</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background: white;
      overflow-x: hidden;
    }

    nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: #111;
      color: white;
      padding: 12px 24px;
      z-index: 999;
      font-size: 18px;
      display: flex;
      gap: 20px;
      font-family: "Noto Serif JP", serif;
    }

    nav a {
      color: white;
      text-decoration: none;
    }

    body {
      padding-top: 70px;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: -10;
    }
  </style>
</head>
<body>

<nav>
  <a href="index.html">Home</a>
  <a href="schedule.html">Schedule</a>
  <a href="contact.html">Contact</a>
  <a href="qa.html">Q&A</a>
</nav>

<div class="corner-message" style="position:fixed;top:72px;left:20px;font-size:20px;color:#111;font-weight:bold;z-index:10;pointer-events:none;font-family:'Noto Serif JP',serif;">
  京都府立医科大学 数学研究部 公式HP
</div>

<!-- ✅ 背景アニメーション：p5.js -->
<script>
new p5(p => {
  const sideLength = 60;
  let triangles = [];
  let points = [];
  let adjacency = new Map();
  let autoWalkers = [];
  let manualWalker;
  let gameOver = false;

  p.setup = () => {
    const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    const cnv = p.createCanvas(p.windowWidth, height);
    cnv.position(0, 0);
    generateTriangleGrid();

    // 自動的に動く点（赤）は生成しない

    // 緑の手動点を初期化（左上）
    const start = getNearestVertex(50, 50);
    manualWalker = new ManualWalker(start);
  };

  p.draw = () => {
    p.background(255);

    // タイル描画
    p.noFill();
    p.stroke(0, 40);
    for (let t of triangles) {
      p.beginShape();
      for (let pt of t) {
        p.vertex(pt.x, pt.y);
      }
      p.endShape(p.CLOSE);
    }

    if (gameOver) {
      p.fill(255, 0, 0);
      p.textSize(60);
      p.textAlign(p.CENTER, p.CENTER);
      p.text("GAME OVER", p.width / 2, p.height / 2);
      return;
    }

    // manualWalker描画
    if (manualWalker.dragging) {
      manualWalker.update(p.createVector(p.mouseX, p.mouseY));
    } else {
      manualWalker.update();
    }
    manualWalker.display();

    // 当たり判定（仮に今後オート点復活したらここに追加）
    // autoWalkers.forEach(w => {
    //   if (p.dist(w.x, w.y, manualWalker.x, manualWalker.y) < 10) {
    //     gameOver = true;
    //   }
    // });
  };

  function generateTriangleGrid() {
    const h = sideLength * Math.sqrt(3) / 2;
    triangles = [];
    adjacency.clear();

    for (let y = 0; y < p.height + h; y += h) {
      for (let x = 0; x < p.width + sideLength; x += sideLength) {
        const xOffset = (Math.floor(y / h) % 2) * (sideLength / 2);
        const p1 = p.createVector(x + xOffset, y);
        const p2 = p.createVector(x + sideLength / 2 + xOffset, y + h);
        const p3 = p.createVector(x - sideLength / 2 + xOffset, y + h);
        triangles.push([p1, p2, p3]);

        registerEdge(p1, p2);
        registerEdge(p2, p3);
        registerEdge(p3, p1);
      }
    }

    points = Array.from(adjacency.values()).map(obj => obj.vec);
  }

  function registerEdge(a, b) {
    const keyA = a.x + ',' + a.y;
    const keyB = b.x + ',' + b.y;

    if (!adjacency.has(keyA)) adjacency.set(keyA, { vec: a, neighbors: [] });
    if (!adjacency.has(keyB)) adjacency.set(keyB, { vec: b, neighbors: [] });

    const neighborsA = adjacency.get(keyA).neighbors;
    const neighborsB = adjacency.get(keyB).neighbors;

    if (!neighborsA.some(n => n.x === b.x && n.y === b.y)) {
      neighborsA.push(adjacency.get(keyB).vec);
    }
    if (!neighborsB.some(n => n.x === a.x && n.y === a.y)) {
      neighborsB.push(adjacency.get(keyA).vec);
    }
  }

  function getNearestVertex(x, y) {
    let minDist = Infinity;
    let nearest = null;
    for (let pt of points) {
      const d = p.dist(x, y, pt.x, pt.y);
      if (d < minDist) {
        minDist = d;
        nearest = pt;
      }
    }
    return nearest;
  }

  class ManualWalker {
    constructor(startVec) {
      this.current = startVec;
      this.next = null;
      this.t = 0;
      this.dragging = false;
    }

    startDrag(targetVec) {
      this.dragging = true;
      this.tryMoveTo(targetVec);
    }

    update(targetVec = null) {
      if (this.dragging && targetVec) {
        const key = this.current.x + "," + this.current.y;
        const neighbors = adjacency.get(key)?.neighbors ?? [];

        let nearest = null;
        let minDist = Infinity;
        for (let n of neighbors) {
          const d = p.dist(n.x, n.y, targetVec.x, targetVec.y);
          if (d < minDist) {
            minDist = d;
            nearest = n;
          }
        }

        if (nearest) {
          this.next = nearest;
        }
      }

      if (this.next && (this.next.x !== this.current.x || this.next.y !== this.current.y)) {
        this.t += 0.08;
        if (this.t >= 1) {
          this.current = this.next;
          this.t = 0;
          this.next = null;
        }
      }
    }

    display() {
      let x = this.current.x;
      let y = this.current.y;

      if (this.next) {
        x = p.lerp(this.current.x, this.next.x, this.t);
        y = p.lerp(this.current.y, this.next.y, this.t);
      }

      p.noStroke();
      p.fill(0, 255, 0, 60); // 緑発光
      p.ellipse(x, y, 24);
      p.fill(0, 180, 0);
      p.ellipse(x, y, 8);
    }

    tryMoveTo(targetVec) {
      const key = this.current.x + "," + this.current.y;
      const neighbors = adjacency.get(key)?.neighbors ?? [];

      for (let n of neighbors) {
        if (p.dist(n.x, n.y, targetVec.x, targetVec.y) < 1) {
          this.next = n;
          this.t = 0;
          return;
        }
      }
    }

    stopDrag() {
      this.dragging = false;
      this.next = null;
    }
  }

  p.mousePressed = () => {
    const start = getNearestVertex(p.mouseX, p.mouseY);
    if (start) manualWalker.startDrag(start);
  };

  p.mouseReleased = () => {
    manualWalker.stopDrag();
  };

  p.windowResized = () => {
    p.resizeCanvas(p.windowWidth, Math.max(document.body.scrollHeight, document.documentElement.scrollHeight));
    generateTriangleGrid();
  };
});
</script>

</body>
</html>
